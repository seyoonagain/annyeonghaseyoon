---
title: 로그인의 흐름
date: 2025-06-03
tags: ['Login']
---

부트캠프에서 팀 프로젝트 당시, 나를 포함한 여러 사람들이 로그인 구현 중 많은 시행착오를 겪었다.  
오늘부터 로그인에 대해 기초부터 정리해나가 보려 한다.

## 인증 vs. 인가

웹 서비스의 로그인 기능을 이해하기 위해 가장 먼저 알아야 할 기본 개념은  
바로 **인증 Authentication**과 **인가 Authorization**의 차이다.

---

### 인증 Authentication

**인증**은 사용자의 신원을 확인하는 절차다.  
예를 들어, 이미 회원가입된 사용자가 본인임을 증명하는 과정이 바로 인증이다.  
일반적으로 로그인 동작이 곧 인증 절차에 해당한다.

---

### 인가 Authorization

**인가**는 인증된 사용자가 어떤 자원에 접근할 수 있는지를 결정하는 절차다.  
같은 회원이라도 권한에 따라 접근 가능한 기능이나 페이지가 다를 수 있다.  
이러한 권한을 설정하고 제한하는 과정이 인가이다.

예를 들어, 일반 사용자는 접근할 수 없고 관리자만 접근할 수 있는 관리자 페이지가 있다면,  
이와 같은 접근 제어는 인가를 통해 구현된다.

## 세션 기반 인증 vs. 토큰 기반 인증

사용자의 신원을 확인하는 인증(Authentication)은 다양한 방식으로 구현할 수 있으며,  
그 중에서도 가장 널리 사용되는 방식이 **세션 기반 인증**과 **토큰 기반 인증**이다.

이 두 방식은 인증 정보를 어떻게 저장하고,  
클라이언트와 서버가 어떤 방식으로 인증을 유지하는지에 차이가 있다.  
각 방식을 단계별로 정리해보자.

---

### 세션 기반 인증

세션 기반 인증은 사용자가 로그인하면,  
서버가 로그인 정보를 **세션에 저장**하고,  
클라이언트에는 해당 세션을 식별할 수 있는 **세션 ID**를 **쿠키에 저장**하도록 하는 방식이다.

> 서버 - 세션에 로그인 정보 저장  
> 클라이언트 - 쿠키에 세션 ID 저장

이후 클라이언트는 매 요청마다 이 세션 ID를 함께 전송하고,  
서버는 이를 통해 사용자가 로그인한 상태인지를 판단한다.

---

#### 세션 기반 인증 절차

1. **사용자 로그인 요청**  
   사용자가 로그인 정보를 입력하고 서버에 로그인 요청을 보낸다.

2. **로그인 정보 확인**  
   서버는 입력된 로그인 정보가 유효한지 확인한다.

3. **세션 생성**  
   로그인 정보가 유효하면 서버는 새로운 세션을 생성한다.  
   이 세션에는 사용자 정보 및 로그인 유지 시간 등의 정보가 포함되며, 서버의 세션 저장소에 저장된다.

4. **세션 ID 발급 및 응답**  
   서버는 세션을 식별할 수 있는 세션 ID를 생성하고,  
   이를 HTTP 응답의 `Set-Cookie` 헤더를 통해 클라이언트에 전달한다.

5. **세션 ID 저장**  
   클라이언트(보통 브라우저)는 서버로부터 전달받은 세션 ID를 쿠키에 저장한다.  
   이후 서버에 요청을 보낼 때마다 브라우저가 자동으로 쿠키를 포함하여 전송한다.

6. **세션 ID 확인 및 인증 처리**  
   서버는 요청에 포함된 세션 ID를 이용해 세션 저장소에서 해당 세션을 조회하고, 사용자가 인증된 상태인지 판단한다.

7. **세션 종료**  
   사용자가 로그아웃하면,  
   서버는 세션 저장소에서 해당 세션을 제거하고,  
   클라이언트는 쿠키를 삭제하거나 무효화한다.

❗ 세션 기반 인증은 서버에서 인증 상태를 기억하기 때문에 사용자가 많아질수록 서버에 저장되는 세션 정보도 늘어나고, 이는 서버 부하로 이어질 수 있다.

---

### 토큰 기반 인증

세션 기반 인증의 단점을 보완하기 위해 등장한 방식이 **토큰 기반 인증**이다.

토큰 기반 인증에서는 사용자 인증 정보를 **서버가 직접 저장하지 않고**,  
JWT(JSON Web Token)와 같은 **토큰에 담아 클라이언트에게 전달**한다.

이후 클라이언트는 이 토큰을 요청마다 포함시켜 인증을 처리하며, 서버는 토큰만으로 사용자를 식별할 수 있게 된다.

> 서버 - 로그인 정보를 담은 토큰을 저장하지 않고 클라이언트에게 전달  
> 클라이언트 - 전달받은 토큰을 저장해 서버에 요청 보낼 때마다 함께 전송

즉, 토큰 기반 인증은 **서버가 상태를 기억하지 않는(Stateless)** 방식으로, 확장성과 유연성 측면에서 장점이 많다.

---

#### 토큰 기반 인증 절차

1.  **사용자 로그인 요청**  
    사용자가 로그인 정보를 입력하고 서버에 로그인 요청을 보낸다.

2.  **로그인 정보 확인**  
    서버는 사용자가 보낸 로그인 정보가 유효한지 확인한다.

3.  **토큰 발급**  
    로그인 정보가 유효하면 서버는 JWT 토큰을 생성한다.  
    토큰 역시 세션과 마찬가지로 사용자 정보와 권한, 만료 시간 등의 정보를 포함한다.  
    하지만 세션과 달리 서버 측에 저장되지 않는다.

4.  **토큰 서명**  
    서버는 비밀키와 해시함수를 이용해 JWT 토큰에 서명함으로써 위변조를 방지하고 무결성을 보장한다.

5.  **토큰 전송**  
    서버는 생성한 토큰을 클라이언트에 응답으로 전달한다.

6.  **토큰 저장**  
    클라이언트는 받은 토큰을 저장한다. 저장 위치는 크게 세 가지가 있다.

    - HttpOnly 쿠키: XSS 공격에 강하며 권장되는 방법
    - Session Storage
    - Local Storage

7.  **인증 요청 시 토큰 전송**  
    클라이언트는 서버에 요청을 보낼 때, 토큰을 함께 전송하여 인증을 진행한다.
    저장 위치에 따라 전송 방식이 달라진다.

    - Session Storage / Local Storage에 저장한 경우  
      → 클라이언트가 직접 토큰을 꺼내 `Authorization` 헤더에 담아 전송한다.  
      이때 일반적으로 'Bearer' 접두사를 사용한다.

      ```http
      	Authorization: Bearer <token>;
      ```

    - HttpOnly 쿠키에 저장한 경우  
      → 토큰은 브라우저가 자동으로 요청의 `Cookie` 헤더에 포함시켜 전송한다.  
      💡 HttpOnly 속성 덕분에 JavaScript에서 쿠키 접근이 불가능하기 때문에  
      클라이언트 측에서 직접 토큰을 꺼내거나 헤더에 추가할 필요가 없다.

8.  **토큰 검증**  
    요청을 받은 서버는 비밀키를 이용하여 토큰의 서명을 검증한 후,  
    토큰으로부터 사용자 정보를 추출하여 인증 여부(로그인 여부)를 판단한다.

9.  **토큰 만료 및 재인증**  
    토큰에는 유효 기간이 있으며, 만료된 토큰은 사용할 수 없다.  
    만료된 경우 클라이언트는 재로그인하거나 리프레시 토큰을 통해 액세스 토큰을 재발급받는다.

---

### 차이점 정리

- 저장 장소

  - 세션: 서버 측에서 저장
  - 토큰: 클라이언트 측에서 저장

- 상태

  - 세션: Stateful (서버가 상태 관리)
  - 토큰: Stateless (서버가 상태를 관리하지 않음)

- 만료 처리

  - 세션: 서버에서 관리
  - 토큰: 토큰 자체에 만료 정보가 포함되어, 만료되면 사용 불가

- 보안 방식

  - 세션: 쿠키로 전달되어 CSRF 공격에 취약
  - 토큰: 토큰: 디지털 서명으로 위변조를 방지

- 유연성

  - 토큰: 인증 정보 외에 추가 정보를 담을 수 있어 세션보다 유연하게 사용

## 마무리

팀 프로젝트 할 때 프론트엔드에서는 HttpOnly 쿠키에 접근할 수가 없는데  
서버에 요청보낼 때 어떻게 해야하는 건지 이해가 잘 안갔던 적이 있었는데,  
이제는 `Authorization` 헤더가 아닌 자동으로 쿠키가 전송된다는 흐름을 이해하게 되었다.  
로그인 흐름의 기초를 다시 정리해보며, 헷갈렸던 개념들이 명확히 정리된 느낌이다.

---

👀 참고 사이트

- [https://dev.to/fidalmathew](https://dev.to/fidalmathew/session-based-vs-token-based-authentication-which-is-better-227o)
